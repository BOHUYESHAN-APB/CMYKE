<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #f6f2ea;
      font-family: sans-serif;
    }
    #c {
      width: 100%;
      height: 100%;
      display: block;
    }
    #status {
      position: absolute;
      top: 8px;
      left: 8px;
      background: rgba(255, 255, 255, 0.82);
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 12px;
      color: #1f2228;
      max-width: 240px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.12);
      line-height: 1.4;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="status">Booting viewer...</div>
  <script>
    const statusEl = document.getElementById('status');
    window.__setStatus = (msg) => {
      statusEl.textContent = msg;
    };
    window.__setStatus('Booting viewer...');
    window.__pendingVrmUrl = null;
    window.loadVrmFromUrl = (url) => {
      window.__pendingVrmUrl = url;
      window.__setStatus('Viewer not ready yet, queued VRM url.');
    };
    window.addEventListener('error', (e) => {
      const detail = e?.message || 'Unknown error';
      window.__setStatus(`JS error: ${detail}`);
    });
    window.addEventListener('unhandledrejection', (e) => {
      const detail = e?.reason?.message || e?.reason || 'Unknown rejection';
      window.__setStatus(`Promise error: ${detail}`);
    });
  </script>
  <script src="/assets/vrm_core/es-module-shims.js"></script>
  <script type="importmap-shim">
    {
      "imports": {
        "three": "/assets/vrm_core/three.module.js",
        "three/addons/": "/assets/vrm_core/jsm/",
        "@pixiv/three-vrm": "/assets/vrm_core/three-vrm.module.js"
      }
    }
  </script>
  <script type="module-shim">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

    const setStatus = window.__setStatus || ((msg) => {
      const el = document.getElementById('status');
      if (el) el.textContent = msg;
    });
    const post = (type, msg) => {
      try {
        window.chrome?.webview?.postMessage(JSON.stringify({ type, msg }));
      } catch (_) {}
    };
    window.onerror = (msg, src, line, col, err) => {
      const detail = `${msg} @ ${src ?? 'unknown'}:${line ?? '?'}:${col ?? '?'}`;
      setStatus(`JS error: ${detail}`);
      post('error', detail);
    };

    function bootstrap() {
      setStatus('Modules ready. Initializing scene...');

      const canvas = document.getElementById('c');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf6f2ea);

      const camera = new THREE.PerspectiveCamera(30, 1, 0.1, 100);
      camera.position.set(0, 1.4, 1.5);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 1.3, 0);
      controls.update();

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(1, 1, 1);
      scene.add(light);
      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      scene.add(hemi);
      const grid = new THREE.GridHelper(4, 8, 0x888888, 0xcccccc);
      grid.position.y = -0.05;
      scene.add(grid);
      const axes = new THREE.AxesHelper(0.5);
      scene.add(axes);

      const loader = new GLTFLoader();
      loader.crossOrigin = 'anonymous';
      loader.register((parser) => new VRMLoaderPlugin(parser));

      let currentVrm = null;
      const clock = new THREE.Clock();
      setStatus('Scene ready. Waiting for VRM...');

      async function loadVrmFromUrl(url) {
        try {
          const gltf = await loader.loadAsync(url);
          if (currentVrm) {
            scene.remove(currentVrm.scene);
            currentVrm = null;
          }
          const vrm = gltf.userData.vrm;
          if (vrm) {
            VRMUtils.removeUnnecessaryVertices(gltf.scene);
            VRMUtils.combineSkeletons(gltf.scene);
            VRMUtils.combineMorphs(vrm);
            vrm.scene.traverse((obj) => {
              obj.frustumCulled = false;
            });
          }
          currentVrm = vrm;
          currentVrm.scene.rotation.y = Math.PI; // face camera
          currentVrm.scene.position.set(0, 0, 0);
          currentVrm.scene.scale.set(1, 1, 1);
          scene.add(currentVrm.scene);
          setStatus('VRM loaded. Use expression/motion hooks to drive avatar.');
          post('info', 'VRM loaded');
        } catch (err) {
          console.error('VRM load error', err);
          setStatus(`VRM load error: ${err}`);
          post('error', `VRM load error: ${err}`);
        }
      }

      async function loadVrmFromBase64(base64) {
        try {
          const binary = Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
          const blob = new Blob([binary], { type: 'application/octet-stream' });
          const url = URL.createObjectURL(blob);
          await loadVrmFromUrl(url);
          URL.revokeObjectURL(url);
        } catch (err) {
          console.error('VRM load error', err);
          setStatus(`VRM load error: ${err}`);
        }
      }

      function setExpression(clip, intensity = 1.0) {
        if (!currentVrm?.expressionManager) return;
        currentVrm.expressionManager.setValue(clip, intensity);
        currentVrm.expressionManager.update();
      }

      function setVisemeWeights(weights) {
        if (!currentVrm?.expressionManager) return;
        Object.entries(weights || {}).forEach(([clip, value]) => {
          currentVrm.expressionManager.setValue(clip, value);
        });
        currentVrm.expressionManager.update();
      }

      function setMotion(motion) {
        if (!currentVrm) return;
        switch (motion) {
          case 'Wave':
            currentVrm.scene.rotation.y = Math.PI + Math.sin(Date.now() / 400) * 0.2;
            break;
          case 'Nod':
            currentVrm.scene.rotation.x = Math.sin(Date.now() / 350) * 0.12;
            break;
          case 'LookLeft':
            currentVrm.scene.rotation.y = Math.PI + 0.3;
            break;
          case 'LookRight':
            currentVrm.scene.rotation.y = Math.PI - 0.3;
            break;
          default:
            currentVrm.scene.rotation.x = 0;
            currentVrm.scene.rotation.y = Math.PI;
        }
      }

      window.loadVrmFromBase64 = loadVrmFromBase64;
      window.loadVrmFromUrl = loadVrmFromUrl;
      window.setExpression = setExpression;
      window.setVisemeWeights = setVisemeWeights;
      window.setMotion = setMotion;

      function resize() {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        renderer.setSize(w, h, false);
        camera.aspect = w / Math.max(h, 1);
        camera.updateProjectionMatrix();
      }
      window.addEventListener('resize', resize);
      resize();

      function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        if (currentVrm) {
          currentVrm.update(delta);
        }
        renderer.render(scene, camera);
      }
      animate();
      setStatus('Viewer ready. Load a VRM to display.');
    }

    try {
      bootstrap();
      if (window.__pendingVrmUrl) {
        const url = window.__pendingVrmUrl;
        window.__pendingVrmUrl = null;
        window.loadVrmFromUrl(url);
      }
    } catch (e) {
      console.error('bootstrap failed', e);
      setStatus(`Bootstrap failed: ${e}`);
    }
  </script>
</body>
</html>
